---
description: WillClaw 后端（Go/Wails）架构约束
alwaysApply: false
---

# Go/Wails 后端编码约束

## 目录职责

当你需要创建或修改后端代码时，遵循以下目录约定：

- `main.go` — 只写启动逻辑，不写业务代码
- `internal/bootstrap/` — 应用组装、窗口创建、服务注册
- `internal/services/*/` — 业务服务，每个服务一个目录
- `internal/services/i18n/` — 多语言服务，翻译文件在 `locales/*.json`
- `internal/services/windows/` — 窗口管理服务
- `internal/errs/` — 业务错误类型
- `internal/sqlite/` — 数据库连接和迁移
- `internal/define/` — 环境配置

## 必须遵守

1. **新建服务时**：放在 `internal/services/[服务名]/`，用 `NewXxxService()` 构造函数
2. **返回错误给前端时**：必须用 `errs.New()` / `errs.Newf()` / `errs.Wrap()`，不要直接返回 `error`
3. **需要翻译的文本**：用 `i18n.T("key")` 或 `i18n.Tf("key", data)`，翻译 key 加到 `internal/services/i18n/locales/*.json`
4. **新建数据库迁移**：放在 `internal/sqlite/migrations/`，文件名格式 `YYYYMMDDHHMM_描述.go`
5. **错误处理**：用 `fmt.Errorf("context: %w", err)` 包装，不要吞掉错误

## 禁止

- 不要在 `main.go` 写业务逻辑
- 不要创建循环依赖（services 之间不要互相 import）
- 不要直接 `log.Fatal`，除非是 `main.go` 中的启动失败
- 不要硬编码用户可见的文本，必须走 i18n
- **不要在函数体内裸调 `syscall.NewCallback` / `windows.NewCallback`**——Go 在 Windows 上只有约 2000 个回调槽位且永不释放，必须用 `sync.Once` 保证只创建一次（详见 `docs/windows-syscall-callback-limit.md`）

## 代码模式

```go
// 创建服务
func NewXxxService(app *application.App) *XxxService {
    return &XxxService{app: app}
}

// 返回业务错误
return errs.Newf("error.xxx_failed", map[string]any{"Name": name})

// 包装底层错误
return errs.Wrap("error.xxx_failed", err)

// 使用翻译
title := i18n.T("window.settings_title")
```

## Windows 回调模式

在 Windows 平台调用 `syscall.NewCallback` / `windows.NewCallback` 时，**必须**用 `sync.Once` 包裹，确保回调只创建一次。回调函数不能是闭包，需通过包级变量传参。

```go
// ✅ 正确
var (
    myCBOnce sync.Once
    myCB     uintptr
    myMu     sync.Mutex
    myParam  string
    myResult uintptr
)

func myEnumProc(hwnd uintptr, _ uintptr) uintptr {
    // use myParam / myResult ...
    return 1
}

func myFunc(param string) uintptr {
    myMu.Lock()
    defer myMu.Unlock()
    myParam = param
    myResult = 0
    myCBOnce.Do(func() { myCB = syscall.NewCallback(myEnumProc) })
    procEnumWindows.Call(myCB, 0)
    return myResult
}

// ❌ 错误 — 每次调用都分配新槽位
func myFunc(param string) uintptr {
    var result uintptr
    cb := syscall.NewCallback(func(hwnd uintptr, _ uintptr) uintptr { ... })
    procEnumWindows.Call(cb, 0)
    return result
}
```
